In this chapter we describe the implementation of a mock producer client.
The purpose of this implementation is to:
\begin{enumberate*}
\item illustrate by example, the workflow of a typical producer client in our system; and
\item provide realistic data for the proof of concept consumer client.
\end{enumberate*}

As stated in \fxnote{ref til afsnit med afgr√¶nsning}, we focus on the server in this project,
which means that the following implementation is relatively simple and not tested beyond inspection of its effects on the system.

\section{Workflow: User --- Producer Client --- Server}
Because we use a standard REST interface for communicating with our server, the implementation details of the producers are not required to be unified across all devices.
E.g.~one producer client may be a dedicated embedded device located in a given vehicle, while another is an app on the driver's generic smartphone of choice.

However all producer clients must follow the same workflow to interact with the server.
This ensures well--defined data for consumption on the consumer client. % chktex 8
Moreover, submitting data out of order, e.g.~waypoint before a route, is simply not possible.

\bigskip
To clarify the workflow we present the following sequence diagram in \cref{fig:producer_workflow},
where a given user interacts with a producer client which then communicates with the server.

The workflow starts with the user logging in, this authenticates the given information with the server and an authentication token (auth token) for the user is returned, if the username and password are correct.
The user then enters basic information about the vehicle, such as make, model, and VIN, if the producer client does not already have this information.
A vehicle is created on the server if necessary.
Before starting the route the producer client must have a route id of an existing route.
This means that unless a valid route id is defined a new route must be created on the server, which will return a route id.
Furthermore any route about to be used, i.e.~driven on, must be marked as \code{ACTIVE}, on the server.

Within the \textit{Driving Loop}, the \code{GatherData()} call is simplified for illustration purposes. % chktex 36
In a concrete implementation the producer client may be configured to transmit GPS data, i.e.~waypoints, more often than vehicle data;
or the waypoint may be omitted if e.g.~no GPS data is available.
This means that submitting waypoints and vehicle data, is independent of each other, and ideally will happen in two different threads --- asynchronously.
As long as the timestamps of all data submissions are correct, the data can be aggregated when requested by the consumer client.

When the vehicle, with the given producer client, has reached its destination the route must be marked as \code{COMPLETED} on the server.
The workflow is then complete and can be repeated on another route and potentially with another vehicle and/or user.

\subimport{bush-did-9/11}{seqdiagram.tex}

\section{Emulation}
Because our mock producer client should be convenient to run and not require significant configuration, a precursory step is introduced.
In this step we utilise a super user in the system to create a new user, which will then be used in the test.
Moreover the mock producer client will also create a new vehicle for every run.

These actions also ensure that the database can be cleared between all runs, as long as the predefined super user is restored.

\bigskip
Since we are emulating the producer client, and therefore simulating the vehicle, we need both fake GPS and vehicle data.
The mocked GPS data is generated by using the Google Maps API\footnote{\url{https://developers.google.com/maps/} --- We used a Python library developed by Google \url{https://pypi.python.org/pypi/googlemaps/}}, which can take two addresses and return a route between those, if available.

We then interpolate the data returned by the Google Maps API, to send GPS coordinates and current speed of a vehicle to the server.

The mock producer client can be controlled from the command line, where start and end points of the route must be defined.
It is also possible to manipulate the duration of the simulation, such that the route will last for a given factor of the original duration.
E.g.~the driving can be sped up to double the speed making a 10 minute route only take 5 minutes, thereby doubling the \textit{current speed} reported to the server.
Time manipulation is used primarily for demonstration purposes.

\section{Validation of Output}
Because the mock producer client is an emulation, and only serves the aforementioned purposes of illustrating an example of communications, and providing data to a proof of concept consumer client,
we do not deem it necessary to systematically test it.

In reality the only testing performed is looking at the output, both to the command line and the HTTP requests to the server, and see if it fits our expectations.
One could argue that this is adequate testing in the case of the mock producer client, since its functioning is not critical to the system.
Moreover we focus heavily on the server, and not this mock as previously mentioned, which in turn means that rigorous testing of a 193 line Python script would be a misuse of resources.
